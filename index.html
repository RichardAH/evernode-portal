<html>
<head>
<!-- currency symbol: ꤲ -->
<!--RH TODO host these files? If so remember to update sandbox injected versions of these -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
integrity="sha384-vp86vTRFVJgpjF9jiIGPEEqYqlDwgyBgEF109VFjmqGmIY/Y4HV4d3Gp2irVfcrp" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/js/all.min.js"
integrity="sha384-9/D4ECZvKMVEJ9Bhr3ZnUAF+Ahlagp1cyPC7h5yDlZdXs4DQ/vRftzfd+2uFUuqS" crossorigin="anonymous"></script>
<script src="https://slowli.github.io/bech32-buffer/assets/js/bech32-buffer.min.js"
integrity="sha384-sIYFdg7cyHQ+74+zO6merf57B9zITFP1al25FBxrMBsvb7EKT61390Gdea4KMSLe" crossorigin="anonymous"></script>
    <style>

        body
        {
            overscroll-behavior: none;
            margin: 0;
            padding: 0;
            user-select: none;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }


        @-moz-keyframes spin { 100% { -moz-transform: rotate(360deg); } }
        @-webkit-keyframes spin { 100% { -webkit-transform: rotate(360deg); } }
        @keyframes spin { 100% { -webkit-transform: rotate(360deg); transform:rotate(360deg); } }

        div#walletspinner {
            width: 100%;
            font-size: 2em;
            text-align: center;
            color: #000eee;
            display: none;
        }

        .fa-spinner
        {
            -webkit-animation: spin 4s linear infinite;
            -moz-animation: spin 4s linear infinite;
            animation: spin 4s linear infinite;
        }

        div#walletbody:before
        {
            content: "Proposed Transaction...";
            font-size: 0.9em;
            margin-left: 0.5em;
            margin-right: 0.5em;
            font-family: monospace;
            color: #000000;
            width: calc(100% - 2em);
            background: #EEEEEE;
            padding: 0.5em;
            display: inline-block;
        }

        div#walletaddrcopy {
            position: absolute;
            right: 1em;
            color: #000eee;
        }

        div#walletbalsend {
            color: #000eee;
        }

        div#walletbalcontainer > *
        {
            display: inline;
        }

        #walletbubble {
            position: fixed;
            z-index: 99999999999999;
            max-width: 20em;
            max-height: 25em;
            width: 20em;
            height: 25em;
            background: white;
            right: 2em;
            top: 2.4em;
            font-family: sans-serif;
            border-radius: 0.5em 0.5em 0.5em 0.5em;
            display: none;
            box-shadow: 0px 1px 5px #00000042;
        }

        div#walletbal:before {
            content: "ꤲ";
            display: inline-block;
            margin-right: 0.3em;
        }

        div#walletheader {
            min-height: 4em;
            border-bottom: 1px solid #f5f5f5;
        }

        div#walletaddr {
            width: 19em;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-left: 50%;
            transform: translate(-50%);
            margin-top: 1em;
            font-family:monospace;
        }

        div#walletbalcontainer {
            width: 100%;
            text-align: center;
            margin-top: 0.5em;
            font-size: 1.2em;
            font-weight: bold;
            font-family: monospace;
        }

        div#walletbody {
            max-width: 20em;
            overflow-wrap: break-word;
            overflow: visible;
            max-height: 15.6em;
            height: 15.6em;
            overflow-y: hidden;
            text-overflow: ellipsis;
            padding-top: 0.2em;
            padding-bottom: 0.2em;
        }

        #walletaccept {
            background: #d8f5db;
            border-radius:0em 0em 0em 1em
        }

        #walletreject {
            background: #f9dcdd;
            position: relative;
            border-radius:0em 0em 1em 0em;
        }

        div#walletbuttons {
            padding: 0.7em;
        }

        div#walletbuttons > button {
            border:0;
            height:2.98em;
            border-radius: 0.5em 0.5em 0.5em 0.5em; 
        }

        div#walletpropose {
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 0.9em;
            padding: 0.5em;
        }



        div#topbarflex {
            display: flex;
            font-family: sans-serif;
            font-size: 0.9em;
            justify-content: left;
            padding-top: 1em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 0.5em;
            max-width: calc(100vw - 1em);
            padding-right: 0.5em;
        }

        div#topbarflex> div {
            background: #dfeaf6;
            color: #2e7cd9;
            padding: 0.5em;
            padding-left: 1em;
            border: none;
            padding-right: 1em;
            height: 1.2em;
            margin: auto;
            margin-right:0.5em;
            text-overflow:ellipsis;
            flex-grow:1;
        }

        div#topbarflex>div:first-of-type {
            border-radius: 1em 0em 0em 1em;
            margin-left:0.5em;
            background: #dfeaf6;
            flex-grow: 2;
            color: black;
        }

        div#topbarflex>div:nth-last-of-type(2){
            border-radius:0em 1em 1em 0em;
        }
        div#topbarflex>#walleticon{
            border-radius:1em 1em 1em 1em;
            max-width:1em;
            max-height:1em;
            padding: 0.5em 0.5em 0.5em 0.5em;
            text-align: center;
            background: white; 
        }

        #topbar {
            position: fixed;
            z-index: 10000;
            background: #f5f5f5;
            top: 0;
            left: 0;
            width: 100vw;
            height: calc(4em - 3px);
            overflow: hidden;
            border-bottom: 3px solid #ececec;
        }

        #sandbox {
            margin-top:4em;
        margin-left: 0em;
        margin-right:0em;
        margin-bottom: 0em;
        padding-left: 0em;
        padding-right: 0em;
        padding-bottom: 0em;
        padding-top: 0em;
        border: none;
        width: 100vw;
        min-height: calc(100vh - 4em);
        }

        div#walletbuttons > button {
            min-width: 10.8em;
        }

        div#walletbuttons > button:not(:first-of-type) {
            margin-left: 0.7em;
        }
    </style>

    <title>Evernode Portal</title>


    <script>

        // we always connect to directory contract first
        // special logic flow retains directory connection in window.directory_hpc while other 
        // contracts are connected to
        async function connect_to_contract(contract_id, contract_keys, contract_peers)
        {
            
            let is_directory = false;
            if (contract_id == window.directory_contract.id)
            {
                is_directory = true;
                contract_peers = window.directory_contract.peers;
                contract_keys = window.directory_contract.keys;
            }

            if (window.sodium.ready === false)
            {
                console.log("connect_to_contract: sodium not ready.");
                return false;
            }

            if (typeof(window.user_keys) == 'undefined')
            {
                if (window.directory_hpc)
                {
                    console.log("DANGER user_keys disappeared during execution, wallet not synced.");
                    // RH TODO add kill switch
                    return;
                }

                let stored_seed = localStorage.getItem('evernode__secret__')
                let decoded = null;

                if (stored_seed)
                try
                {
                    decoded = bech32.decode(stored_seed);
                    if (decoded.prefix != 'evernode__secret__' || decoded.data.length != 32)
                        throw new Error('invalid seed');
                }
                catch (e)
                {
                    console.log(e);
                    console.log('decode failed')
                    prompt('IMPORTANT. Decoding your evernode secret failed. Please backup the below',
                            stored_seed);
                    localStorage.setItem('failed__evernode__secret__' + Date.now(), stored_seed);
                }

                if (stored_seed == null || decoded == null)
                {
                    window.user_keys = await HotPocket.generateKeys();
                    let seed = bech32.encode('evernode__secret__', window.user_keys.privateKey.slice(0,32));
                    localStorage.setItem('evernode__secret__', seed);
                }
                else
                {
                    let hex = decoded.data.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
                    window.user_keys = await HotPocket.generateKeys(hex);         
                }
            
                window.user_keys.bech32 = bech32.encode('evernode', window.user_keys.publicKey);
            }

            if (typeof(contract_keys.length) != 'number' || contract_keys.length < 1)
            {
                console.log("connect_to_contract: contract_keys should be an array with at least one element.");
                return false;
            }

            if (typeof(contract_peers.length) != 'number' || contract_peers.length < 1)
            {
                console.log("connect_to_contract: contract_peers should be an array with at least one element.");
                return false;
            }

            window.contract_id = contract_id;
            window.contract_keys = contract_keys;
            window.contract_peers = contract_peers;
        
            if (is_directory && window.directory_hpc)
                window.directory_hpc.close();
            else if (window.hpc)
                window.hpc.close();

            topbarhtml =
                '<div id="evernodeurl" style="background: '+(is_directory ? '#d8f5db' : '#fff6cc' ) + 
                '">evernode://' + contract_id + '</div>';

            for (let i = 0; i < contract_peers.length; ++i)
                topbarhtml += '<div class="evernodepeer">' + contract_peers[i] + '</div>';

            topbarhtml += '<div id="walleticon" style="background:white" onclick="toggle_wallet(Date.now())"><i class="fa fa-user" aria-hidden="true"></i></div>';

            document.getElementById('topbarflex').innerHTML = topbarhtml;

            let hpc_instance = await HotPocket.createClient(contract_peers, user_keys, {
                contractId: contract_id,
                validServerKeys: contract_keys
            });

            if (!await hpc_instance.connect()) {
                console.log('connect_to_contract: connection failed.');
                return false;
            }

            if (is_directory)
                window.directory_hpc = hpc_instance;
            else
                window.hpc = hpc_instance;

            console.log('connect_to_contract: hotpocket connected.');

            // Simple connection to single server without any validations.

            // Maintain multiple connections with contract id/version and server key validation.
            // const options = {
            //     contractId: "3c349abe-4d70-4f50-9fa6-018f1f2530ab",
            //     contractVersion: "1.0",
            //     validServerKeys: [
            //         "ed5597c207bbd251997b7133d5d83a2c6ab9600810edf0bdb43f4004852b8c9e17",
            //         "ed0b2ffd75b67c3979d3c362d8350ec190f053fa27d3dfcb2eced426efd1d3affc",
            //         "edd2e1a817387d68adf8adb1d0b339e3f04868c3c81bf6a7472647f10657e31aa1"
            //     ],
            //     protocol: HotPocket.protocols.json,
            //     requiredConnectionCount: 2,
            //     connectionTimeoutMs: 5000
            // };
            // const hpc = await HotPocket.createClient(
            //     [
            //         "wss://localhost:8081",
            //         "wss://localhost:8082",
            //         "wss://localhost:8083"
            //     ], keys, options);


            // This will get fired if HP server disconnects unexpectedly.
            hpc_instance.on(HotPocket.events.disconnect, () => {
                console.log('Disconnected');
            })

            // This will get fired as servers connects/disconnects after the initial connection establishment.
            hpc_instance.on(HotPocket.events.connectionChange, (server, action) => {
                console.log(server + " " + action);
            })

        }


        window.sodium = {
            ready: false,
            onload: async function (sodium) {

                window.sodium = sodium;
            }
        };


        window.directory_contract =
        {
            id: "49aac5c8-96db-4cc3-8c93-8a733de2fa4b",
            keys: ["edd2d77c20ea5cf895969e4f8117e85176d3c72f6ce059382eb946fdd34ae031f4"],
            peers: ["wss://eve.evernode.org"]
        };

        function interframe_wrap(obj)
        {

            if (!window.sodium || window.sodium.ready === false)
            {
                console.log('interframe_wrap: sodium not ready.');
                return false;
            }

            let inner = {
                content: obj,
                nonce: ++window.our_nonce
            };

            let outer = {
                payload: JSON.stringify(inner)
            };

            outer.hash =
                sodium.crypto_generichash(16, sodium.from_string(outer.payload), window.evernode_cookie, 'hex');

            return JSON.stringify(outer);
        }

        function interframe_unwrap(s)
        {

            if (!window.sodium || window.sodium.ready === false)
            {
                console.log('interframe_unwrap: sodium not ready.');
                return false;
            }

            let outer = JSON.parse(s);
            if (!outer.hash || !outer.payload)
            {
                console.log('interframe_unwrap: message did not include hash or payload or both.');
                return false;
            }

            let cookie = window.evernode_cookie;

            let calc_hash = sodium.crypto_generichash(16, sodium.from_string(outer.payload), cookie, 'hex');

            if (calc_hash != outer.hash)
            {
                console.log('interframe_unwrap: message did not have the correct hash.');
                return false;
            }

            let inner = JSON.parse(outer.payload);
            if (!inner.nonce)
            {
                console.log('interframe_unwrap: message did not have a nonce.');
                return false;
            }

            if (typeof(window.other_nonce) == 'undefined')
                window.other_nonce = 0;

            if (inner.nonce <= window.other_nonce)
            {
                console.log('interframe_unwrap: message has an old or reused nonce (replay attack).');
                return false;
            }

            window.other_nonce = inner.nonce;

            return { is_directory: cookie == window.directory_cookie, content: inner.content };
        }

        function interframe_send(obj)
        {
            let m = window.interframe_wrap(obj);
            if (m === false)
                return;

            if (window.origin == 'null')
                return window.parent.postMessage(m, '*');

            return document.getElementById('sandbox').contentWindow.postMessage(m, '*');
        }

        // RH TODO rpc should route multiple requests through multiple peers
        // RH TODO other than for read requests some sort of UNL proof of validation should be provided by
        //         connected peers
        function rpc(method, params, for_directory)
        {

            let in_sandbox = window.origin == 'null';

            let hpc = (for_directory ? window.directory_hpc : window.hpc);

            if (!in_sandbox && typeof(hpc) == 'undefined')
            {
                console.log("rpc: not connected to a contract");
                return false;
            }

            if (typeof(window.pending_rpc) == 'undefined')
            {
                window.pending_rpc = {};

                let response_handler = (response) => {
                    if (typeof(response) != 'object')
                    {
                        console.log("received invalid json response from contract");
                        return;
                    }

                    if (!('jsonrpc' in response) || response['jsonrpc'] != '2.0' || !('id' in response))
                        return console.log("received non-jsonrpc response from contract");

                    if (!(response.id in window.pending_rpc))
                        return console.log("received invalid response id from contract " + response.id);

                    let promise = window.pending_rpc[response.id];
                    delete window.pending_rpc[response.id];

                    if ('error' in response)
                        return promise.reject(response.error);

                    if (!('result' in response))
                        return console.log("received invalid response from contract (no result field)");

                    promise.resolve(response.result);
                };

                if (in_sandbox)
                    window.rpc_response_handler = response_handler;
                else
                {
                    hpc.on(HotPocket.events.contractReadResponse, response_handler);
                    hpc.on(HotPocket.events.contractOutput, response_handler);
                }
            }

            if (typeof(window.jsonrpc_nonce) == 'undefined')
                window.jsonrpc_nonce = 0;

            let request_id = ++window.jsonrpc_nonce;

            let request = {
                jsonrpc: "2.0",
                method: method,
                id: request_id
            };

            if (typeof(params) != 'undefined')
                request['params'] = params;

            request = JSON.stringify(request);

            let retval = new Promise((resolve, reject) => {
                window.pending_rpc[request_id] = { resolve: resolve, reject: reject };
                setTimeout(()=> {
                    if (window.pending_rpc[request_id])
                        reject(JSON.stringify({code: -32003, message: "RPC timeout"}));
                }, 10000);
            });

            if (in_sandbox)
                interframe_send({type: 'rpc', data: request})
            else
            {
                if (method.match(/^info_/))
                    hpc.sendContractReadRequest(request)
                else
                    hpc.sendContractInput(request);
            }
            return retval;
        }

        // propose an action for the directory contract for the user to decide if they will take
        function propose(nonce, proposal)
        {

            if (typeof(window.last_proposal_id) != 'undefined' && window.last_proposal_id >= nonce)
                return console.log("proposal nonce must increment since the last proposal");

            let proposal_id = nonce;
            window.last_proposal_id = proposal_id;

            let in_sandbox = window.origin == 'null';
            
            let p = {};

            if (!('method' in proposal))
                return console.log("received propose message without method key");

            p.method = proposal.method;
        
            if ('params' in proposal)
                p.params = proposal.params;
            else
                p.params = {};

            if (typeof(window.pending_proposal) == 'undefined')
                window.pending_proposal = {};

            if (proposal_id in window.pending_proposal)
                return console.log("proposal id already exists");

            p.proposal_id = proposal_id;

            let retval = new Promise((resolve, reject) => {
                window.pending_proposal[proposal_id] = { resolve: resolve, reject: reject, proposal: p };
            });


            if (in_sandbox)
            {
                interframe_send({type: 'proposal', data: JSON.stringify(p)});
            }
            else
            {
                toggle_wallet(Date.now(), {
                    method: p.method,
                    params: p.params,
                    proposal_id: p.proposal_id
                }, false);
            }

            return retval;
        }


        function interframe_message_handler(event)
        {

            let in_sandbox = window.origin == 'null';

            if (in_sandbox && typeof(window.rpc_response_handler) == 'undefined')
            {
                console.log("sandbox_onmessage: could not find rpc handler");
                return false;
            }
        
            if (event.origin == window.origin)
                return; // ignore self messages

            let j = interframe_unwrap(event.data);
            if (j === false || !('is_directory' in j) || !('content' in j))
                return; // invalid message

            let is_directory = j.is_directory;
            j = j.content;

            // api:
            // type ::= resize | status | reconnect | directory | rpc | load
            // resize     -  height of sandbox has changed
            // status     -  connection status, how many nodes are connected to the guid of the contract and the
            //               node's public keys
            // reconnect  -  ask for a fresh connection to the same contract we are already on
            // directory  -  load the directory contract
            // load       -  load a specified contract (if not initiated by directory contract then via warning)


            if (j.type == 'ping')
            {
                interframe_send({type: 'pong'});
                return;
            }

            if (j.type == 'resize')
            {
                if (in_sandbox)
                    return console.log("interframe_message_handler: received resize message inside sandbox");

                document.getElementById('sandbox').style.height = j.data + 'px';
                return;
            }

            if (j.type == 'status')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received status message inside sandbox");

            }

            if (j.type == 'reconnect')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received reconnect message inside sandbox");

            }

            if (j.type == 'directory')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received directory message inside sandbox");

                document.location.reload();
                return;
            }

            if (j.type == 'load')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received load message inside sandbox");
            }

            if (j.type == 'propose')
            {
                if (in_sandbox)
                    return console.log("interframe_message_handler: received propose message inside sandbox");

                if (!('data' in j))
                    return console.log("interframe_message_handler: propose request missing data field");

                try
                {
                    let data = JSON.parse(j.data);
                }
                catch (e)
                {
                    return console.log(
                        "interframe_message_handler: received propose message with non-json data field");
                }

                if (!('method' in data))
                    return console.log("interframe_message_handler: propose message missing data.method");
            
                let inner_proposal_id = null;
                if (!('proposal_id' in data))
                    inner_proposal_id = data.proposal_id;

                let p = {
                    method: data.method,
                    params: (data.params ? data.params : {})
                };

                let response_handler = x => {
                };

                propose(Date.now(), p).then( x=> {
                    interframe_send({
                        type: proposal_response,
                        data: JSON.stringify(x), 
                        proposal_id: inner_proposal_id,
                        success: true
                    });
                }).catch ( x=> {
                    interframe_send({
                        type: proposal_response,
                        data: JSON.stringify(x), 
                        proposal_id: inner_proposal_id,
                        success: false
                    });
                });

                
                return;
            }

            if (j.type == 'propose_response')
            {
                if (!in_sandbox)
                    return console.log("interframe_message_handler: received propose_response message in top frame");

                if (!('data' in j))
                    return console.log("interframe_message_handler: propose_response missing data field");

                if (!('proposal_id' in j))
                    return console.log("interframe_message_handler: propose_response missing proposal_id field");
                
                if (!(j.proposal_id in window.pending_proposal))
                    return console.log("interframe_message_handler: propose_response referenced a proposal_id " + 
                        "which does not exist.");

                if (j.success)
                    window.pending_proposal[j.proposal_id].resolve(j.data);
                else
                    window.pending_proposal[j.proposal_id].reject(j.data);

                return;
            }

            if (j.type == 'rpc')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received rpc message inside sandbox");
            
                if (!('data' in j))
                    return console.log("interframe_message_handler: rpc request missing data field");
        
                j.data = JSON.parse(j.data);

                if (!('id' in j.data) || !('method' in j.data))
                    return console.log("interframe_message_handler: rpc request missing id/method");
    
                let resolve =
                    result => {
                    console.log("resolving inner rpc id: " + j.data.id);
                    console.log(j)
                    interframe_send({
                        type: 'rpc_response',
                        data: {
                            'jsonrpc': '2.0',
                            'result': result,
                            'id': j.data.id
                        }
                    });
                  };
                
                let reject =
                    error => {
                        interframe_send({
                            type: 'rpc_response',
                            data: {
                                'jsonrpc': '2.0',
                                'error': error,
                                'id': j.data.id
                            }
                        });
                    };


                if ('params' in j.data)
                    return rpc(j.data.method, j.data.params, is_directory).then(resolve).catch(reject);

                return rpc(j.data.method, {}, is_directory).then(resolve).catch(reject);
            }

            if (j.type == 'rpc_response')
            {
                if (!in_sandbox)
                    return console.log("interframe_message_handler: received rpc_response message outside sandbox");
                return window.rpc_response_handler(j.data);
            }

        }



        window.addEventListener("message", interframe_message_handler, false);


        function reset_sandbox(html, is_directory)
        {


            window.evernode_cookie = new Uint8Array(64);
            window.evernode_cookie_current = "";
            crypto.getRandomValues(window.evernode_cookie);
            if (is_directory)
                window.directory_cookie = window.evernode_cookie;
            window.our_nonce = 0;
            window.their_nonce = 0;
            const inject1 = "<" + "script>\r\n" +
                            "window.evernode_cookie = new Uint8Array([" + window.evernode_cookie + "]);\r\n" +
                            "window.our_nonce = 0;\r\n" +
                            "window.their_nonce = 0;\r\n" +
                            interframe_wrap.toString() + ";\r\n" +
                            interframe_unwrap.toString() + ";\r\n" +
                            interframe_send.toString() + ";\r\n" +
                            interframe_message_handler.toString() + ";\r\n" +
                            rpc.toString() + ";\r\n" +
                            "window.addEventListener('message', interframe_message_handler, false);\r\n" +
                            "window.sodium = {\r\n" +
                            "ready: false,\r\n"+
                            "onload: \r\n" +
                            "async function (sodium) {\r\n" +
                            "window.sodium = sodium; \r\n" +
                            "(new ResizeObserver(entries => {\r\n" +
                            "console.log('resize observer fired');\r\n" +
                            "interframe_send(\r\n" +
                            "{type: 'resize', data: \r\n" +
                            "Math.max(document.body.scrollHeight, document.body.offsetHeight, " +
                            "document.documentElement.clientHeight, document.documentElement.scrollHeight, " +
                            "document.documentElement.offsetHeight)\r\n" +
                            "});}\r\n"+
                            ")).observe(document.documentElement);\r\n" +
                            "}};<" + "/script>\r\n";

            const inject2 = '<'+'script ' +
                            'src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/sodium.min.js" ' +
                            'integrity="sha512-oRfU7aik4u7f0dPAKgOyA4+bb/YRGfAaD5RA4Z3Mb2yc' +
                            'PcGDs+k8qAnDNd7ouruoqlIHSuGVaTTlEs91Gvd37A==" crossorigin="anonymous">' +
                            '<'+'/script>' + "\r\n" +
                            '<'+'link rel="stylesheet" ' + 
                            'href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" ' +
                            'integrity="sha384-vp86vTRFVJgpjF9jiIGPEEqYqlDwgyBgEF109VFjmqGmIY/Y4HV4d3Gp2irVfcrp" ' +
                            'crossorigin="anonymous">' + "\r\n" +
                            '<'+'script ' +
                            'src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/js/all.min.js" ' +
                            'integrity="sha384-9/D4ECZvKMVEJ9Bhr3ZnUAF+Ahlagp1cyPC7h5yDlZdXs4DQ/vRftzfd+2uFUuqS" ' +
                            'crossorigin="anonymous"><'+'/script>' + "\r\n" + 
                            '<'+'script ' +
                            'src="https://slowli.github.io/bech32-buffer/assets/js/bech32-buffer.min.js" ' +
                            'integrity="sha384-sIYFdg7cyHQ+74+zO6merf57B9zITFP1al25FBxrMBsvb7EKT61390Gdea4KMSLe" ' +
                            'crossorigin="anonymous"><'+'/script>' + "\r\n";

            let sandbox_element = document.getElementById('sandbox');
            if (!sandbox_element)
                return console.log('sandbox element missing');

            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<!DOCTYPE[^>]+>/ig, '');
            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<html[^>]+>/ig, '');
            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<head[^>]+>/ig, '');

            sandbox_element.srcdoc = "<!DOCTYPE HTML>\r\n<html>\r\n<head>\r\n" + inject1 + inject2 + html;
        }

        window.addEventListener("load", (event) =>
        {
            // open websocket connection/s
            // populate top bar
            // call info_main(cookie)
            // populate/create sandbox iframe

        }, false);


       
     
        function toggle_wallet(nonce, proposal, force_close)
        {

            console.log("toggle_wallet, proposal:");
            console.log(proposal);

            update_balance();

            if (force_close)
            {
                document.getElementById('walletbubble').style.display = 'none';
                document.getElementById('walletpropose').innerHTML = '';
                document.getElementById('walleticon').style.background = 'white';
                return;
            }

            if (typeof(window.wallet_nonce) == 'number' && window.wallet_nonce >= nonce)
                return;

            window.wallet_nonce = nonce;        

            if (typeof(proposal) != 'object' && typeof(proposal) != 'string' && typeof(proposal) != 'undefined')
                return console.log("toggle_wallet: invalid proposal, should be string or object");

            if (typeof(proposal) == 'object')
                proposal = JSON.stringify(proposal);

            let proposal_id = null;
            if (typeof(proposal) == 'string')
            {
                try
                {
                    proposal_obj = JSON.parse(proposal);
                    if (typeof(proposal_obj.proposal_id) != 'undefined')
                        proposal_id = proposal_obj.proposal_id;
                }
                catch(e)
                {
                    console.log("toggle_wallet: invalid proposal passed (must be json)");
                    return;
                }
            }


            let is_proposal = typeof(proposal) == 'string';

            if (is_proposal && proposal_id == null)
                return console.log("toggle_wallet: attempt to pass a proposal without a proposal_id");

            document.getElementById('walletaddr').innerHTML = window.user_keys.bech32;
            document.getElementById('walletbal').innerHTML = (typeof(window.user_keys.balance) == 'number' ?
                window.user_keys.balance : ' - ');

            let is_hidden = document.getElementById('walleticon').style.background == 'white';

            // proposals always open the dialog
            if (is_proposal)
            {
                is_hidden = true;
                window.current_proposal = proposal;
            }

            if (!is_proposal)
            {
                document.getElementById('walletbody').style.display = 'none';
                document.getElementById('walletbubble').style.height = '9em';
            }
            else
            {
                document.getElementById('walletbody').style.display = 'block';
                document.getElementById('walletbubble').style.height = '25em';
            }
 
            if (is_hidden)
            {
                document.getElementById('walletbubble').style.display = 'block';
                document.getElementById('walleticon').style.background = '#c4c4c4';
                if (is_proposal)
                {
                    document.getElementById('walletpropose').style.display = 'block';
                    document.getElementById('walletpropose').innerHTML = 
                        JSON.stringify(JSON.parse(proposal), null, 2);
                    document.getElementById('walletaccept').innerHTML = 'Submit';
                    document.getElementById('walletreject').innerHTML = 'Reject';
                    document.getElementById('walletaccept').dataset.proposal_id = proposal_id;
                    document.getElementById('walletreject').dataset.proposal_id = proposal_id;
                } else
                { 
                    document.getElementById('walletpropose').style.display = 'block';
                    document.getElementById('walletpropose').innerHTML = '';
                    document.getElementById('walletaccept').innerHTML = 'Secret';
                    document.getElementById('walletreject').innerHTML = 'Restore Wallet';
                    document.getElementById('walletaccept').dataset.proposal_id = null;
                    document.getElementById('walletreject').dataset.proposal_id = null;
                }
            } else
            {
                document.getElementById('walleticon').style.background = 'white';
                document.getElementById('walletbubble').style.display = 'none';
                document.getElementById('walletpropose').innerHTML = '';
                document.getElementById('walletpropose').dataset.proposal_id = null;
                document.getElementById('walletaccept').dataset.proposal_id = null;
                document.getElementById('walletreject').dataset.proposal_id = null;
            }
        }


        function wallet_click(nonce, button, proposal_id)
        {

            if (typeof(proposal_id) == 'string')
                proposal_id = parseInt(proposal_id, 10)

            console.log('wallet_click proposal_id: ' + proposal_id);

            if (typeof(window.wallet_nonce) == 'number' && window.wallet_nonce >= nonce)
                return;

            window.wallet_nonce = nonce;


            if (typeof(button) != 'string')
                return;

            button = button.toLowerCase();

            if (button == 'secret')
            {
                prompt('This is your secret, protect it!', bech32.encode('evernode__secret__',
                    window.user_keys.privateKey.slice(0,32)));
                return;
            }

            if (button == 'restore wallet')
            {
                let new_seed = prompt('Paste your evernode secret below to restore',
                                      'Warning this will override exisitng wallet.');
                if (new_seed)
                try
                {
                    let decoded = bech32.decode(new_seed);

                    if (typeof(decoded) != 'object')
                        throw new Error('Invalid bech32.');

                    if (decoded.prefix != 'evernode__secret__' || decoded.data.length != 32)
                        throw new Error('Invalid evernode secret.');

                    localStorage.setItem('evernode__secret__', new_seed); 
                                    
                    alert('Page will now reload with your secret');
                    
                    window.location.reload();  

                }
                catch (e)
                {
                    alert('Wallet restore failed. Check you entered the full seceret. ' + e);
                }
                return;
            }

            if (button == 'submit')
            {

                if (typeof(proposal_id) != 'number')
                {
                    console.log("invalid proposal_id passed to wallet_click: " + proposal_id + " : " + typeof(proposal_id));
                    return;
                }
            

                let cleanup = ()=>
                {
                    toggle_wallet(Date.now(), null, true);
                    document.getElementById('walletbuttons').style.display = 'block';
                    document.getElementById('walletspinner').style.display = 'none';
                };


                let proposal_obj = null; 
                try
                {
                    proposal_obj = JSON.parse(window.current_proposal);
                    if (proposal_obj.proposal_id != proposal_id)
                        return console.log("wallet_click: refusing to submit when current_proposal doesn't match " +
                            "proposal_id attached to submit button");

                    
                    document.getElementById('walletbuttons').style.display = 'none';
                    document.getElementById('walletspinner').style.display = 'block';

                    rpc(proposal_obj.method, proposal_obj.params, true).then( x=>
                    {
                        let resolver = window.pending_proposal[proposal_id];
                        if (resolver)
                            resolver.resolve(x);
                        cleanup();
                    }).catch( e=>
                    {
                        alert('Error submitting: ' + e);
                        let resolver = window.pending_proposal[proposal_id];
                        if (resolver)
                            resolver.reject(e);
                        cleanup();
                    });
                }
                catch (e)
                {
                    alert('Error submitting: ' + e);
                    cleanup();
                }
                return; 
            }

            if (button == 'reject')
            {
                toggle_wallet(Date.now(), null, true);
                let resolver = window.pending_proposal[proposal_id];
                if (resolver)
                    resolver.reject(JSON.stringify({
                        success: false, info: "user cancelled"
                    }));
                return;
            }
            
        }

    function copy_address()
    {
        prompt('Copy your public address from below', document.getElementById('walletaddr').innerText);
    }

    function send_dialog()
    {
        // RH TODO: clean up this, make a dedicated dialog for it
        let to = prompt('Enter a destination address. You will get to check this at the end.');
        if (to == null)
            return;

        try
        {
            let decoded = bech32.decode(to);
            if (decoded.prefix != 'evernode')
                throw new Error('bad prefix');
            if (decoded.data.length != 32)
                throw new Error('bad length');
        }
        catch (e)
        {
            alert('Specified address is not a valid evernode address. Should start with evernode1. ' + e);
            return;
        }

        let amt = '';
        do 
        {
            amt = prompt('Enter an amount of Evers to send. You will get to check this at the end.');
            if (amt == null)
                return;
            try 
            {
                amt = parseFloat(amt + '', 10);
            }
            catch (e)
            {
                amt = null
            }
            if (typeof(amt) != 'number')
                alert('Invalid number. Please enter only decimal digits.');
        }
        while (typeof(amt) != 'number');
       
        propose(Date.now(), 
        {
            method: "evers_send",
            params: {
                to: to,
                amt: amt,
                seq: Date.now()
            },
            proposal_id: Date.now()
        }).then( x=> { alert("Evers Sent!"); }).catch( x=> {alert("Failed!");});
    }


    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/sodium.min.js"
        integrity="sha512-oRfU7aik4u7f0dPAKgOyA4+bb/YRGfAaD5RA4Z3Mb2ycPcGDs+k8qAnDNd7ouruoqlIHSuGVaTTlEs91Gvd37A=="
        crossorigin="anonymous"></script>
    <script src="https://richardah.github.io/evernode-portal/hp-client-lib.js"></script>
</head>
<body>

<div id="walletbubble">
    <div id="walletheader">
        <div id="walletaddrcopy"><i class="far fa-copy" onclick="copy_address()"></i></div>
        <div id="walletaddr"></div>
        <div id="walletbalcontainer">
            <div id="walletbal"></div>
            <div id="walletbalsend"><i class="fas fa-paper-plane" onclick="send_dialog()"></i></div>
        </div>
    </div>
    <div id="walletbody">
        <div style="" id="walletpropose"></div>
    </div>
    <div id="walletspinner">
        <i class="fas fa-spinner"></i>
    </div>
    <div id="walletbuttons">
        <button id="walletaccept" onclick="wallet_click(Date.now(), this.innerText, this.dataset.proposal_id);">Submit</button><button id="walletreject" onclick="wallet_click(Date.now(), this.innerText, this.dataset.proposal_id);">Reject</button>
    </div>
</div>

<div id="topbar">
    <div id="topbarflex">
        <div id="evernodeurl">
        </div>
        <div class="evernodepeer">
        </div>
    </div>
</div>


<iframe id="sandbox" src="#" seamless sandbox="allow-scripts" scrolling="no" srcdoc="..."></iframe>

<script defer>
    reset_sandbox('Loading ...');


    function update_balance()
    {
        rpc('info_account', {"acc": window.user_keys.bech32}, true).then( x => {
            x = JSON.parse(x);
            window.user_keys.balance = x.amount;
            document.getElementById('walletbal').innerHTML = '' + x.amount;
        }).catch(e => {console.log(e);});
    }
    
    connect_to_contract(
        window.directory_contract.id,
        window.directory_contract.keys,
        window.directory_contract.peers
    ).then( (x)=>
    {
        if (x === false)
        {
            reset_sandbox('<html><head></head><body><h1>Failed to connect to directory contract.</h1></body></html>');
            return;
        }
        console.log("connected to directory");
        rpc('info_main', {}, true).then( result => {

            reset_sandbox(result, true);

            update_balance();


        }).catch(y=>{
            console.log(y);
        });

    })

</script>
</body>

</html>
