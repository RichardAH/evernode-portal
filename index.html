<html>
<head>
    <style>

        body {
            background:blue;
            overscroll-behavior: none;
            margin: 0;
            padding: 0;
        }

        div#topbarflex {
            display: flex;
            font-family: sans-serif;
            font-size: 0.9em;
            justify-content: left;
            padding-top: 1em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 0.5em;
            max-width: calc(100vw - 1em);
            padding-right: 0.5em;
        }

        div#topbarflex> * {
            background:  rgb(241 243 255 / 1);
            padding: 0.5em;
            padding-left: 1em;
            border: none;
            padding-right: 1em;
            height: 1.2em;
            margin: auto;
            margin-right:0.5em;
            text-overflow:ellipsis;
            flex-grow:1;

        }

        div#topbarflex> *:first-of-type {
            margin-left:0.5em;
            background:hsl(133 100% 90% / 1);
            border-radius: 1em 0em 0em 1em;
            flex-grow: 2;
        }

        div#topbarflex > *:last-of-type {
            border-radius:0em 1em 1em 0em;
            margin-left:0em
        }

        #topbar {
            position: fixed;
            z-index: 10000;
            background: hsl(0 0% 88% / 1);
            top: 0;
            left: 0;
            width: 100vw;
            height: calc(4em - 3px);
            overflow: hidden;
            border-bottom: 3px solid rgb(0 0 0 / 0.14);
        }

        #sandbox {
            margin-top:4em;
            margin-left: 0em;
            margin-right:0em;
            margin-bottom: 0em;
            padding-left: 0em;
            padding-right: 0em;
            padding-bottom: 0em;
            padding-top: 0em;
            border: none;
            width: 100vw; 
            min-height: calc(100vh - 4em);
        }

        

    </style>

    <title>Evernode Portal</title>


    <script>

        async function connect_to_contract(contract_peers, contract_keys)
        {

            if (window.sodium.ready === false)
            {
                console.log("connect_to_contract: sodium not ready.");
                return false;
            }

            if (typeof(window.user_keys) == 'undefined')
                window.user_keys = await HotPocket.generateKeys(); 
               

            if (typeof(contract_keys.length) != 'number' || contract_keys.length < 1)
            {
                console.log("connect_to_contract: contract_keys should be an array with at least one element.");
                return false;
            }

            if (typeof(contract_peers.length) != 'number' || contract_peers.length < 1)
            {
                console.log("connect_to_contract: contract_peers should be an array with at least one element.");
                return false;
            }

            window.contract_keys = contract_keys;
            window.contract_peers = contract_peers;
            
            if (window.hpc)
                hpc.close();
            
            
            window.hpc = await HotPocket.createClient(contract_peers, user_keys);

            if (!await hpc.connect()) {
                console.log('connect_to_contract: connection failed.');
                return false;
            }
            
            console.log('connect_to_contract: hotpocket connected.');

            // Simple connection to single server without any validations.

            // Maintain multiple connections with contract id/version and server key validation.
            // const options = {
            //     contractId: "3c349abe-4d70-4f50-9fa6-018f1f2530ab",
            //     contractVersion: "1.0",
            //     validServerKeys: [
            //         "ed5597c207bbd251997b7133d5d83a2c6ab9600810edf0bdb43f4004852b8c9e17",
            //         "ed0b2ffd75b67c3979d3c362d8350ec190f053fa27d3dfcb2eced426efd1d3affc",
            //         "edd2e1a817387d68adf8adb1d0b339e3f04868c3c81bf6a7472647f10657e31aa1"
            //     ],
            //     protocol: HotPocket.protocols.json,
            //     requiredConnectionCount: 2,
            //     connectionTimeoutMs: 5000
            // };
            // const hpc = await HotPocket.createClient(
            //     [
            //         "wss://localhost:8081",
            //         "wss://localhost:8082",
            //         "wss://localhost:8083"
            //     ], keys, options);


            // This will get fired if HP server disconnects unexpectedly.
            hpc.on(HotPocket.events.disconnect, () => {
                console.log('Disconnected');
            })

            // This will get fired as servers connects/disconnects after the initial connection establishment.
            hpc.on(HotPocket.events.connectionChange, (server, action) => {
                console.log(server + " " + action);
            })

            // This will get fired when contract sends an output.
            hpc.on(HotPocket.events.contractOutput, (output) => {
                console.log("Contract output>> " + output);
            })


            if (typeof(window.jsonrpc_nonce) == "undefined")
                window.jsonrpc_nonce = 0;


            // When we need to close HP connection:
            // await hpc.close();

        }


        window.sodium = {
            ready: false,
            onload: async function (sodium) {

                window.sodium = sodium;
            }
        };




        function interframe_wrap(obj)
        {
            
            if (!window.sodium || window.sodium.ready === false)
            {
                console.log('interframe_wrap: sodium not ready.');
                return false;
            }

            let inner = {
                content: obj,
                nonce: ++window.our_nonce
            };
            let outer = {
                payload: JSON.stringify(inner)
            };
            outer.hash = sodium.crypto_generichash(16, sodium.from_string(outer.payload),
                                                    window.evernode_cookie, 'hex');
            return JSON.stringify(outer);
        }

        function interframe_unwrap(s)
        {

            if (!window.sodium || window.sodium.ready === false)
            {
                console.log('interframe_unwrap: sodium not ready.');
                return false;
            }

            let outer = JSON.parse(s);
            if (!outer.hash || !outer.payload)
            {
                console.log('interframe_unwrap: message did not include hash or payload or both.');
                return false;
            }

            let calc_hash = sodium.crypto_generichash(16, sodium.from_string(outer.payload),
                                                       window.evernode_cookie, 'hex');

            if (calc_hash != outer.hash)
            {
                console.log('interframe_unwrap: message did not have the correct hash.');
                return false;
            }

            let inner = JSON.parse(outer.payload);
            if (!inner.nonce)
            {
                console.log('interframe_unwrap: message did not have a nonce.');
                return false;
            }


            if (inner.nonce <= window.other_nonce)
            {
                console.log('interframe_unwrap: message has an old or reused nonce (replay attack).');
                return false;
            }
        
            window.other_nonce = inner.nonce;            

            return inner.content;
        }

        function interframe_send(obj)
        {
            let m = window.interframe_wrap(obj);
            if (m === false)
                return;

            if (window.origin == 'null')
                return window.parent.postMessage(m, '*');

            return document.getElementById('sandbox').contentWindow.postMessage(m, '*');
        }

        window.addEventListener("message", (event) =>
        {
            if (event.origin == window.origin)
                return; // ignore self messages

            let j = interframe_unwrap(event.data);
            if (j === false)
                return; // invalid message

            // type ::= resize | status | reconnect | directory | rpc | load
            // resize     -  height of sandbox has changed
            // status     -  connection status, how many nodes are connected to the guid of the contract and the
            //               node's public keys
            // reconnect  -  ask for a fresh connection to the same contract we are already on
            // directory  -  load the directory contract
            // load       -  load a specified contract (if not initiated by directory contract then via warning)


            if (j.type == 'ping')
            {
                interframe_send({type: 'pong'});
                return;
            }

            if (j.type == 'resize')
            {
                document.getElementById('sandbox').style.height = j.data + 'px';
                return;
            }

            if (j.type == 'status')
            {
                

            }

            if (j.type == 'reconnect')
            {


            }

            if (j.type == 'directory')
            {


            }

            if (j.type == 'load')
            {


            }

        },false);

        function reset_sandbox(html)
        {

            window.evernode_cookie = new Uint8Array(64);
            window.evernode_cookie_current = "";
            crypto.getRandomValues(window.evernode_cookie);
            window.our_nonce = 0;
            window.their_nonce = 0;

            const inject1 = "<" + "script>\r\n" +
                            "window.evernode_cookie = new Uint8Array([" + window.evernode_cookie + "]);\r\n" + 
                            "window.our_nonce = 0;\r\n" + 
                            "window.their_nonce = 0;\r\n" + 
                            interframe_wrap.toString() + ";\r\n" + 
                            interframe_unwrap.toString() + ";\r\n" + 
                            interframe_send.toString() + ";\r\n" + 
                            "window.sodium = {\r\n" +
                            "ready: false,\r\n"+
                            "onload: \r\n" + 
                            "async function (sodium) {\r\n" +
                            "window.sodium = sodium; \r\n" +
                            "(new ResizeObserver(entries => {\r\n" + 
                            "console.log('resize observer fired');\r\n" +
                            "interframe_send(\r\n" + 
                            "{type: 'resize', data: \r\n" + 
                            "Math.max(document.body.scrollHeight, document.body.offsetHeight, " +
                            "document.documentElement.clientHeight, document.documentElement.scrollHeight, " + 
                            "document.documentElement.offsetHeight)\r\n" +
                            "});}\r\n"+
                            ")).observe(document.documentElement);\r\n" +
                            "}};<" + "/script>\r\n";

            const inject2 = '<'+'script src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/' + 
                            'sodium.min.js" integrity="sha512-oRfU7aik4u7f0dPAKgOyA4+bb/YRGfAaD5RA4Z3Mb2yc' +
                            'PcGDs+k8qAnDNd7ouruoqlIHSuGVaTTlEs91Gvd37A==" crossorigin="anonymous"><'+'/script>' + 
                            "\r\n";

            let sandbox_element = document.getElementById('sandbox');
            if (!sandbox_element)
                return console.log('sandbox element missing');

            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<!DOCTYPE[^>]+>/ig, '');
            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<html[^>]+>/ig, '');
            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<head[^>]+>/ig, '');

            sandbox_element.srcdoc = "<!DOCTYPE HTML>\r\n<html>\r\n<head>\r\n" + inject1 + inject2 + html;
        }

        window.addEventListener("load", (event) =>
        {
            // open websocket connection/s
            // populate top bar
            // call info_main(cookie)
            // populate/create sandbox iframe

        }, false);

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/sodium.min.js"
        integrity="sha512-oRfU7aik4u7f0dPAKgOyA4+bb/YRGfAaD5RA4Z3Mb2ycPcGDs+k8qAnDNd7ouruoqlIHSuGVaTTlEs91Gvd37A=="
        crossorigin="anonymous"></script>
    <script src="https://richardah.github.io/evernode-portal/hp-client-lib.js"></script>
</head>
<body>
<div id="topbar">
    <div id="topbarflex">
        <div id="evernodeurl">
            evernode://98167360-e721-4165-bc30-7851804d734a [directory contract]
        </div>
        <div class="evernodepeer">
            wss://test.evernode.org
        </div>
    </div>
</div>


<iframe id="sandbox" src="#" seamless sandbox="allow-scripts" scrolling="no" srcdoc="..."></iframe>

<script defer>
    reset_sandbox('Loading ...');


    function rpc(method, params)
    {
        if (typeof(window.hpc) == 'undefined')
        {
            console.log("rpc: not connected to a contract");
            return false;
        }

        if (typeof(window.pending_rpc) == 'undefined')
        {
            window.pending_rpc = {};

            let response_handler = (response) => {
                
                if (!('jsonrpc' in response) || response['jsonrpc'] != '2.0' || !('id' in response))
                    return console.log("received non-jsonrpc response from contract");

                if (!('result' in response))
                    return console.log("received invalid response from contract (no result field)");
                
                if (!(response.id in window.pending_rpc))
                    return console.log("received invalid response id from contract " + response.id);

                let promise = window.pending_rpc[response.id];
                delete window.pending_rpc[response.id];

                promise.resolve(response.result);
            };

            hpc.on(HotPocket.events.contractReadResponse, response_handler);
            hpc.on(HotPocket.events.contractOutput, response_handler);            
        }

        let request_id = ++window.jsonrpc_nonce;

        let request = {
            jsonrpc: "2.0",
            method: method,
            id: request_id
        };

        if (typeof(params) != 'undefined')
            request['params'] = params;
        
        request = JSON.stringify(request);
        
        let retval = new Promise((resolve, reject) => { 
            window.pending_rpc[request_id] = { resolve: resolve, reject: reject };
            setTimeout( ()=>{ if(window.pending_rpc[request_id]) reject('timeout') }, 10000 );
        });

        if (method.match(/^info_/))
            hpc.sendContractReadRequest(request)
        else
            hpc.sendContractInput(request);

        return retval;
    }

    connect_to_contract(["wss://eve.evernode.org"],[0]).then( ()=>
    {
        console.log("connected!~!");

        rpc('info_main').then( result => {
            sandbox.srcdoc = result
        }).catch(y=>{
            console.log(y);
        });

    })
</script>
</body>

</html>
