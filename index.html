<html>
<head>
    <style>

        body {
            background:blue;
            overscroll-behavior: none;
            margin: 0;
            padding: 0;
        }

        div#topbarflex {
            display: flex;
            font-family: sans-serif;
            font-size: 0.9em;
            justify-content: left;
            padding-top: 1em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 0.5em;
            max-width: calc(100vw - 1em);
            padding-right: 0.5em;
        }

        div#topbarflex> * {
            background:  #f1f3ff;
            padding: 0.5em;
            padding-left: 1em;
            border: none;
            padding-right: 1em;
            height: 1.2em;
            margin: auto;
            margin-right:0.5em;
            text-overflow:ellipsis;
            flex-grow:1;

        }

        div#topbarflex> *:first-of-type {
            margin-left:0.5em;
            background: #f1f3ff;
            border-radius: 1em 0em 0em 1em;
            flex-grow: 2;
        }

        div#topbarflex > *:last-of-type {
            border-radius:0em 1em 1em 0em;
            margin-left:0em
        }

        #topbar {
            position: fixed;
            z-index: 10000;
            background: hsl(0 0% 88% / 1);
            top: 0;
            left: 0;
            width: 100vw;
            height: calc(4em - 3px);
            overflow: hidden;
            border-bottom: 3px solid rgb(0 0 0 / 0.14);
        }

        #sandbox {
            margin-top:4em;
            margin-left: 0em;
            margin-right:0em;
            margin-bottom: 0em;
            padding-left: 0em;
            padding-right: 0em;
            padding-bottom: 0em;
            padding-top: 0em;
            border: none;
            width: 100vw;
            min-height: calc(100vh - 4em);
        }



    </style>

    <title>Evernode Portal</title>


    <script>

        async function connect_to_contract(contract_id, contract_keys, contract_peers)
        {

            if (window.sodium.ready === false)
            {
                console.log("connect_to_contract: sodium not ready.");
                return false;
            }

            if (typeof(window.user_keys) == 'undefined')
                window.user_keys = await HotPocket.generateKeys();


            if (typeof(contract_keys.length) != 'number' || contract_keys.length < 1)
            {
                console.log("connect_to_contract: contract_keys should be an array with at least one element.");
                return false;
            }

            if (typeof(contract_peers.length) != 'number' || contract_peers.length < 1)
            {
                console.log("connect_to_contract: contract_peers should be an array with at least one element.");
                return false;
            }

            window.contract_id = contract_id;
            window.contract_keys = contract_keys;
            window.contract_peers = contract_peers;

            if (window.hpc)
                hpc.close();

            let is_directory = false;
            if (contract_id == window.directory_contract.id)
            {
                is_directory = true;
                contract_peers = window.directory_contract.peers;
                contract_keys = window.directory_contract.keys;
            }

            topbarhtml =
                '<div id="evernodeurl" style="background: '+(is_directory ? '#ccffe8' : '#fff6cc' ) + 
                '">evernode://' + contract_id + '</div>';

            for (let i = 0; i < contract_peers.length; ++i)
                topbarhtml += '<div class="evernodepeer">' + contract_peers[i] + '</div>';

            document.getElementById('topbarflex').innerHTML = topbarhtml;

            window.hpc = await HotPocket.createClient(contract_peers, user_keys, {
                contractId: contract_id,
                validServerKeys: contract_keys
            });

            if (!await hpc.connect()) {
                console.log('connect_to_contract: connection failed.');
                return false;
            }

            console.log('connect_to_contract: hotpocket connected.');

            // Simple connection to single server without any validations.

            // Maintain multiple connections with contract id/version and server key validation.
            // const options = {
            //     contractId: "3c349abe-4d70-4f50-9fa6-018f1f2530ab",
            //     contractVersion: "1.0",
            //     validServerKeys: [
            //         "ed5597c207bbd251997b7133d5d83a2c6ab9600810edf0bdb43f4004852b8c9e17",
            //         "ed0b2ffd75b67c3979d3c362d8350ec190f053fa27d3dfcb2eced426efd1d3affc",
            //         "edd2e1a817387d68adf8adb1d0b339e3f04868c3c81bf6a7472647f10657e31aa1"
            //     ],
            //     protocol: HotPocket.protocols.json,
            //     requiredConnectionCount: 2,
            //     connectionTimeoutMs: 5000
            // };
            // const hpc = await HotPocket.createClient(
            //     [
            //         "wss://localhost:8081",
            //         "wss://localhost:8082",
            //         "wss://localhost:8083"
            //     ], keys, options);


            // This will get fired if HP server disconnects unexpectedly.
            hpc.on(HotPocket.events.disconnect, () => {
                console.log('Disconnected');
            })

            // This will get fired as servers connects/disconnects after the initial connection establishment.
            hpc.on(HotPocket.events.connectionChange, (server, action) => {
                console.log(server + " " + action);
            })

        }


        window.sodium = {
            ready: false,
            onload: async function (sodium) {

                window.sodium = sodium;
            }
        };


        window.directory_contract =
        {
            id: "87bb9148-0e7f-4896-985e-fa8aee641e03",
            keys: ["ed4f9b1f7b787d4bda65cd33b3554f5acdf710e1a773815464398511321f0775ed"],
            peers: ["wss://eve.evernode.org"]
        };

        function interframe_wrap(obj)
        {

            if (!window.sodium || window.sodium.ready === false)
            {
                console.log('interframe_wrap: sodium not ready.');
                return false;
            }

            let inner = {
                content: obj,
                nonce: ++window.our_nonce
            };

            let outer = {
                payload: JSON.stringify(inner)
            };

            outer.hash =
                sodium.crypto_generichash(16, sodium.from_string(outer.payload), window.evernode_cookie, 'hex');

            return JSON.stringify(outer);
        }

        function interframe_unwrap(s)
        {

            if (!window.sodium || window.sodium.ready === false)
            {
                console.log('interframe_unwrap: sodium not ready.');
                return false;
            }

            let outer = JSON.parse(s);
            if (!outer.hash || !outer.payload)
            {
                console.log('interframe_unwrap: message did not include hash or payload or both.');
                return false;
            }

            let calc_hash = sodium.crypto_generichash(16, sodium.from_string(outer.payload),
                                                       window.evernode_cookie, 'hex');

            if (calc_hash != outer.hash)
            {
                console.log('interframe_unwrap: message did not have the correct hash.');
                return false;
            }

            let inner = JSON.parse(outer.payload);
            if (!inner.nonce)
            {
                console.log('interframe_unwrap: message did not have a nonce.');
                return false;
            }


            if (inner.nonce <= window.other_nonce)
            {
                console.log('interframe_unwrap: message has an old or reused nonce (replay attack).');
                return false;
            }

            window.other_nonce = inner.nonce;

            return inner.content;
        }

        function interframe_send(obj)
        {
            let m = window.interframe_wrap(obj);
            if (m === false)
                return;

            if (window.origin == 'null')
                return window.parent.postMessage(m, '*');

            return document.getElementById('sandbox').contentWindow.postMessage(m, '*');
        }

        // RH TODO rpc should route multiple requests through multiple peers
        // RH TODO other than for read requests some sort of UNL proof of validation should be provided by connected peers
        function rpc(method, params)
        {

            let in_sandbox = window.origin == 'null';

            if (!in_sandbox && typeof(window.hpc) == 'undefined')
            {
                console.log("rpc: not connected to a contract");
                return false;
            }

            if (typeof(window.pending_rpc) == 'undefined')
            {
                window.pending_rpc = {};

                let response_handler = (response) => {

                    if (!('jsonrpc' in response) || response['jsonrpc'] != '2.0' || !('id' in response))
                        return console.log("received non-jsonrpc response from contract");

                    if (!(response.id in window.pending_rpc))
                        return console.log("received invalid response id from contract " + response.id);

                    let promise = window.pending_rpc[response.id];
                    delete window.pending_rpc[response.id];

                    if ('error' in response)
                        return promise.reject(response.error);

                    if (!('result' in response))
                        return console.log("received invalid response from contract (no result field)");

                    promise.resolve(response.result);
                };

                if (in_sandbox)
                    window.rpc_response_handler = response_handler;
                else
                {
                    hpc.on(HotPocket.events.contractReadResponse, response_handler);
                    hpc.on(HotPocket.events.contractOutput, response_handler);
                }
            }

            if (typeof(window.jsonrpc_nonce) == 'undefined')
                window.jsonrpc_nonce = 0;

            let request_id = ++window.jsonrpc_nonce;

            let request = {
                jsonrpc: "2.0",
                method: method,
                id: request_id
            };

            if (typeof(params) != 'undefined')
                request['params'] = params;

            request = JSON.stringify(request);

            let retval = new Promise((resolve, reject) => {
                window.pending_rpc[request_id] = { resolve: resolve, reject: reject };
                setTimeout(()=> {
                    if (window.pending_rpc[request_id])
                        reject(JSON.stringify({code: -32003, message: "RPC timeout"}));
                }, 10000);
            });

            if (in_sandbox)
                interframe_send({type: 'rpc', data: request})
            else
            {
                if (method.match(/^info_/))
                    hpc.sendContractReadRequest(request)
                else
                    hpc.sendContractInput(request);
            }
            return retval;
        }
        function interframe_message_handler(event)
        {

            let in_sandbox = window.origin == 'null';

            if (in_sandbox && typeof(window.rpc_response_handler) == 'undefined')
            {
                console.log("sandbox_onmessage: could not find rpc handler");
                return false;
            }
        
            if (event.origin == window.origin)
                return; // ignore self messages

            let j = interframe_unwrap(event.data);
            if (j === false)
                return; // invalid message

            // api:
            // type ::= resize | status | reconnect | directory | rpc | load
            // resize     -  height of sandbox has changed
            // status     -  connection status, how many nodes are connected to the guid of the contract and the
            //               node's public keys
            // reconnect  -  ask for a fresh connection to the same contract we are already on
            // directory  -  load the directory contract
            // load       -  load a specified contract (if not initiated by directory contract then via warning)


            if (j.type == 'ping')
            {
                interframe_send({type: 'pong'});
                return;
            }

            if (j.type == 'resize')
            {
                if (in_sandbox)
                    return console.log("interframe_message_handler: received resize message inside sandbox");

                document.getElementById('sandbox').style.height = j.data + 'px';
                return;
            }

            if (j.type == 'status')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received status message inside sandbox");

            }

            if (j.type == 'reconnect')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received reconnect message inside sandbox");

            }

            if (j.type == 'directory')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received directory message inside sandbox");


            }

            if (j.type == 'load')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received load message inside sandbox");
            }

            if (j.type == 'rpc')
            {
                if (in_sandbox) 
                    return console.log("interframe_message_handler: received rpc message inside sandbox");
            
                if (!('data' in j))
                    return console.log("interframe_message_handler: rpc request missing data field");
        
                j.data = JSON.parse(j.data);

                if (!('id' in j.data) || !('method' in j.data))
                    return console.log("interframe_message_handler: rpc request missing id/method");
    
                let resolve =
                    result => {
                    console.log("resolving inner rpc id: " + j.data.id);
                    console.log(j)
                    interframe_send({
                        type: 'rpc_response',
                        data: {
                            'jsonrpc': '2.0',
                            'result': result,
                            'id': j.data.id
                        }
                    });
                  };
                
                let reject =
                    error => {
                        interframe_send({
                            type: 'rpc_response',
                            data: {
                                'jsonrpc': '2.0',
                                'error': error,
                                'id': j.data.id
                            }
                        });
                    };

                if ('params' in j.data)
                    return rpc(j.data.method, j.data.params).then(resolve).catch(reject);

                return rpc(j.data.method).then(resolve).catch(reject);
            }

            if (j.type == 'rpc_response')
            {
                if (!in_sandbox)
                    return console.log("interframe_message_handler: received rpc_response message outside sandbox");
                return window.rpc_response_handler(j.data);
            }

        }



        window.addEventListener("message", interframe_message_handler, false);

        function reset_sandbox(html)
        {

            window.evernode_cookie = new Uint8Array(64);
            window.evernode_cookie_current = "";
            crypto.getRandomValues(window.evernode_cookie);
            window.our_nonce = 0;
            window.their_nonce = 0;
            const inject1 = "<" + "script>\r\n" +
                            "window.evernode_cookie = new Uint8Array([" + window.evernode_cookie + "]);\r\n" +
                            "window.our_nonce = 0;\r\n" +
                            "window.their_nonce = 0;\r\n" +
                            interframe_wrap.toString() + ";\r\n" +
                            interframe_unwrap.toString() + ";\r\n" +
                            interframe_send.toString() + ";\r\n" +
                            interframe_message_handler.toString() + ";\r\n" +
                            rpc.toString() + ";\r\n" +
                            "window.addEventListener('message', interframe_message_handler, false);\r\n" +
                            "window.sodium = {\r\n" +
                            "ready: false,\r\n"+
                            "onload: \r\n" +
                            "async function (sodium) {\r\n" +
                            "window.sodium = sodium; \r\n" +
                            "(new ResizeObserver(entries => {\r\n" +
                            "console.log('resize observer fired');\r\n" +
                            "interframe_send(\r\n" +
                            "{type: 'resize', data: \r\n" +
                            "Math.max(document.body.scrollHeight, document.body.offsetHeight, " +
                            "document.documentElement.clientHeight, document.documentElement.scrollHeight, " +
                            "document.documentElement.offsetHeight)\r\n" +
                            "});}\r\n"+
                            ")).observe(document.documentElement);\r\n" +
                            "}};<" + "/script>\r\n";

            const inject2 = '<'+'script src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/' +
                            'sodium.min.js" integrity="sha512-oRfU7aik4u7f0dPAKgOyA4+bb/YRGfAaD5RA4Z3Mb2yc' +
                            'PcGDs+k8qAnDNd7ouruoqlIHSuGVaTTlEs91Gvd37A==" crossorigin="anonymous"><'+'/script>' +
                            "\r\n";

            let sandbox_element = document.getElementById('sandbox');
            if (!sandbox_element)
                return console.log('sandbox element missing');

            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<!DOCTYPE[^>]+>/ig, '');
            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<html[^>]+>/ig, '');
            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<head[^>]+>/ig, '');

            sandbox_element.srcdoc = "<!DOCTYPE HTML>\r\n<html>\r\n<head>\r\n" + inject1 + inject2 + html;
        }

        window.addEventListener("load", (event) =>
        {
            // open websocket connection/s
            // populate top bar
            // call info_main(cookie)
            // populate/create sandbox iframe

        }, false);

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/sodium.min.js"
        integrity="sha512-oRfU7aik4u7f0dPAKgOyA4+bb/YRGfAaD5RA4Z3Mb2ycPcGDs+k8qAnDNd7ouruoqlIHSuGVaTTlEs91Gvd37A=="
        crossorigin="anonymous"></script>
    <script src="https://richardah.github.io/evernode-portal/hp-client-lib.js"></script>
</head>
<body>
<div id="topbar">
    <div id="topbarflex">
        <div id="evernodeurl">
        </div>
        <div class="evernodepeer">
        </div>
    </div>
</div>


<iframe id="sandbox" src="#" seamless sandbox="allow-scripts" scrolling="no" srcdoc="..."></iframe>

<script defer>
    reset_sandbox('Loading ...');



    
    connect_to_contract(
        window.directory_contract.id,
        window.directory_contract.keys,
        window.directory_contract.peers
    ).then( ()=>
    {
        console.log("connected!~!");

        rpc('info_main').then( result => {
            reset_sandbox(result);
        }).catch(y=>{
            console.log(y);
        });

    })

</script>
</body>

</html>
