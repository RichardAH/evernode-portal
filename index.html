<html>
<head>
    <style>

        body {
            background:blue;
            overscroll-behavior: none;
            margin: 0;
            padding: 0;
        }

        div#topbarflex {
            display: flex;
            font-family: sans-serif;
            font-size: 0.9em;
            justify-content: left;
            padding-top: 1em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-left: 0.5em;
            max-width: calc(100vw - 1em);
            padding-right: 0.5em;
        }

        div#topbarflex> * {
            background:  rgb(241 243 255 / 1);
            padding: 0.5em;
            padding-left: 1em;
            border: none;
            padding-right: 1em;
            height: 1.2em;
            margin: auto;
            margin-right:0.5em;
            text-overflow:ellipsis;
            flex-grow:1;

        }

        div#topbarflex> *:first-of-type {
            margin-left:0.5em;
            background:hsl(133 100% 90% / 1);
            border-radius: 1em 0em 0em 1em;
            flex-grow: 2;
        }

        div#topbarflex > *:last-of-type {
            border-radius:0em 1em 1em 0em;
            margin-left:0em
        }

        #topbar {
            position: fixed;
            z-index: 10000;
            background: hsl(0 0% 88% / 1);
            top: 0;
            left: 0;
            width: 100vw;
            height: calc(4em - 3px);
            overflow: hidden;
            border-bottom: 3px solid rgb(0 0 0 / 0.14);
        }

        #sandbox {
            margin-top:4em;
            margin-left: 0em;
            margin-right:0em;
            margin-bottom: 0em;
            padding-left: 0em;
            padding-right: 0em;
            padding-bottom: 0em;
            padding-top: 0em;
            border: none;
            width: 100vw; 
            min-height: calc(100vh - 4em);
        }

        

    </style>

    <title>Evernode Portal</title>
    <script> /* inline: hp-browser-client-lib.js */
        window.HotPocket = (() => {

            const protocols = {
                json: "json"
            }
            Object.freeze(protocols);

            const events = {
                disconnect: "disconnect",
                contractOutput: "contractOutput",
                contractReadResponse: "contractReadResponse"
            }
            Object.freeze(events);

            const fromHexString = hexString =>
                new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

            const toHexString = bytes =>
                bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');

            const KeyGenerator = {
                generate: function (privateKeyHex = null) {

                    if (!privateKeyHex) {
                        const keys = sodium.crypto_sign_keypair();
                        return {
                            privateKey: keys.privateKey,
                            publicKey: keys.publicKey
                        }
                    }
                    else {
                        const binPrivateKey = fromHexString(privateKeyHex);
                        return {
                            privateKey: Uint8Array.from(binPrivateKey),
                            publicKey: Uint8Array.from(binPrivateKey.slice(32))
                        }
                    }
                },
            }

            function EventEmitter() {
                const registrations = {};

                this.on = (eventName, listener) => {
                    if (!registrations[eventName])
                        registrations[eventName] = [];
                    registrations[eventName].push(listener);
                }

                this.emit = (eventName, value) => {
                    if (registrations[eventName])
                        registrations[eventName].forEach(listener => listener(value));
                }
            }

            HotPocketClient = function HotPocketClient(contractId, server, keys) {

                let ws = null;
                const protocol = protocols.json; // We only support json in browser.
                const msgHelper = new MessageHelper(keys, protocol);
                const emitter = new EventEmitter();

                let handshakeResolver = null;
                let statResponseResolvers = [];
                let contractInputResolvers = {};

                this.connect = function () {
                    return new Promise(resolve => {

                        handshakeResolver = resolve;

                        ws = new WebSocket(server);

                        ws.addEventListener("close", () => {
                            // If there are any ongoing resolvers resolve them with error output.

                            handshakeResolver && handshakeResolver(false);
                            handshakeResolver = null;

                            statResponseResolvers.forEach(resolver => resolver(null));
                            statResponseResolvers = [];

                            Object.values(contractInputResolvers).forEach(resolver => resolver(null));
                            contractInputResolvers = {};

                            emitter.emit(events.disconnect);
                        });

                        ws.onmessage = async (rcvd) => {

                            msg = await rcvd.data.text();

                            try {
                                m = msgHelper.deserializeMessage(msg);
                            } catch (e) {
                                console.log(e);
                                console.log("Exception deserializing: ");
                                console.log(msg);
                                return;
                            }

                            if (m.type == 'handshake_challenge') {
                                // Check whether contract id is matching if specified.
                                if (contractId && m.contract_id != contractId) {
                                    console.error("Contract id mismatch.")
                                    ws.close();
                                }

                                // sign the challenge and send back the response
                                const response = msgHelper.createHandshakeResponse(m.challenge);
                                ws.send(JSON.stringify(response));

                                setTimeout(() => {
                                    // If we are still connected, report handshaking as successful.
                                    // (If websocket disconnects, handshakeResolver will be null)
                                    handshakeResolver && handshakeResolver(true);
                                    handshakeResolver = null;
                                }, 100);
                            }
                            else if (m.type == 'contract_read_response') {
                                emitter.emit(events.contractReadResponse, msgHelper.deserializeOutput(m.content));
                            }
                            else if (m.type == 'contract_input_status') {
                                const sigKey = (typeof m.input_sig === "string") ? m.input_sig : m.input_sig.toString("hex");
                                const resolver = contractInputResolvers[sigKey];
                                if (resolver) {
                                    if (m.status == "accepted")
                                        resolver("ok");
                                    else
                                        resolver(m.reason);
                                    delete contractInputResolvers[sigKey];
                                }
                            }
                            else if (m.type == 'contract_output') {
                                emitter.emit(events.contractOutput, msgHelper.deserializeOutput(m.content));
                            }
                            else if (m.type == "stat_response") {
                                statResponseResolvers.forEach(resolver => {
                                    resolver({
                                        lcl: m.lcl,
                                        lclSeqNo: m.lcl_seqno
                                    });
                                })
                                statResponseResolvers = [];
                            }
                            else {
                                console.log("Received unrecognized message: type:" + m.type);
                            }
                        }
                    });
                };

                this.on = function (event, listener) {
                    emitter.on(event, listener);
                }

                this.close = function () {
                    return new Promise(resolve => {
                        try {
                            ws.addEventListener("close", resolve);
                            ws.close();
                        } catch (error) {
                            resolve();
                        }
                    })
                }

                this.getStatus = function () {
                    const p = new Promise(resolve => {
                        statResponseResolvers.push(resolve);
                    });

                    // If this is the only awaiting stat request, then send an actual stat request.
                    // Otherwise simply wait for the previously sent request.
                    if (statResponseResolvers.length == 1) {
                        const msg = msgHelper.createStatusRequest();
                        ws.send(msgHelper.serializeObject(msg));
                    }
                    return p;
                }

                this.sendContractInput = async function (input, nonce = null, maxLclOffset = null) {

                    if (!maxLclOffset)
                        maxLclOffset = 10;

                    if (!nonce)
                        nonce = (new Date()).getTime().toString();
                    else
                        nonce = nonce.toString();

                    // Acquire the current lcl and add the specified offset.
                    const stat = await this.getStatus();
                    if (!stat)
                        return new Promise(resolve => resolve("ledger_status_error"));
                    const maxLclSeqNo = stat.lclSeqNo + maxLclOffset;

                    const msg = msgHelper.createContractInput(input, nonce, maxLclSeqNo);
                    const sigKey = (typeof msg.sig === "string") ? msg.sig : msg.sig.toString("hex");
                    const p = new Promise(resolve => {
                        contractInputResolvers[sigKey] = resolve;
                    });

                    ws.send(msgHelper.serializeObject(msg));
                    return p;
                }

                this.sendContractReadRequest = function (request) {
                    const msg = msgHelper.createReadRequest(request);
                    ws.send(msgHelper.serializeObject(msg));
                }
            }

            function MessageHelper(keys, protocol) {

                this.binaryEncode = function (data) {
                    return toHexString(data);
                }

                this.serializeObject = function (obj) {
                    return JSON.stringify(obj);
                }

                this.deserializeMessage = function (m) {
                    return JSON.parse(m);
                }

                this.serializeInput = function (input) {
                    return (typeof input === 'string' || input instanceof String) ? input : input.toString();
                }

                this.deserializeOutput = function (content) {
                    return content;
                }

                this.createHandshakeResponse = function (challenge) {
                    // For handshake response encoding Hot Pocket always uses json.
                    // Handshake response will specify the protocol to use for subsequent messages.
                    const sigBytes = sodium.crypto_sign_detached(challenge, keys.privateKey);

                    return {
                        type: "handshake_response",
                        challenge: challenge,
                        sig: toHexString(sigBytes),
                        pubkey: "ed" + toHexString(keys.publicKey),
                        protocol: protocol
                    }
                }

                this.createContractInput = function (input, nonce, maxLclSeqNo) {

                    if (input.length == 0)
                        return null;

                    const inpContainer = {
                        input: this.serializeInput(input),
                        nonce: nonce,
                        max_lcl_seqno: maxLclSeqNo
                    }

                    const serlializedInpContainer = this.serializeObject(inpContainer);
                    const sigBytes = sodium.crypto_sign_detached(serlializedInpContainer, keys.privateKey);

                    const signedInpContainer = {
                        type: "contract_input",
                        input_container: serlializedInpContainer,
                        sig: this.binaryEncode(sigBytes)
                    }

                    return signedInpContainer;
                }

                this.createReadRequest = function (request) {

                    if (request.length == 0)
                        return null;

                    return {
                        type: "contract_read_request",
                        content: this.serializeInput(request)
                    }
                }

                this.createStatusRequest = function () {
                    return { type: 'stat' };
                }
            }

            return {
                KeyGenerator: KeyGenerator,
                Client: HotPocketClient,
                events: events,
            }
        })(); /* end inline file */


        /* start bootstrap code */

        window.sodium = {
            ready: false,
            onload: async function (sodium) {

                window.sodium = sodium;
                const keys = HotPocket.KeyGenerator.generate();
                        // Can provide existing hex private key as parameter as well.
                const hpc = new HotPocket.Client(null, "wss://test.evernode.org", keys);

                if (!await hpc.connect()) {
                    console.log('Connection failed.');
                    return;
                }
                console.log('HotPocket Connected.');

                // This will get fired if HP server disconnects unexpectedly.
                hpc.on(HotPocket.events.disconnect, () => {
                    console.log('Server disconnected');
                })

                // This will get fired when contract sends an output.
                hpc.on(HotPocket.events.contractOutput, (output) => {
                    console.log("Contract output>> " + output);
                })

                // This will get fired when contract sends a read response.
                hpc.on(HotPocket.events.contractReadResponse, (response) => {
                    console.log("Contract read response>> " + response);
                })

                hpc.sendContractReadRequest("Hello");
                hpc.sendContractInput("World!")

                // When we need to close HP connection:
                // hpc.close();
            }
        };




        function interframe_wrap(obj)
        {
            
            if (!window.sodium || window.sodium.ready === false)
            {
                console.log('interframe_wrap: sodium not ready.');
                return false;
            }

            let inner = {
                content: obj,
                nonce: ++window.our_nonce
            };
            let outer = {
                payload: JSON.stringify(inner)
            };
            outer.hash = sodium.crypto_generichash(16, sodium.from_string(outer.payload),
                                                    window.evernode_cookie, 'hex');
            return JSON.stringify(outer);
        }

        function interframe_unwrap(s)
        {

            if (!window.sodium || window.sodium.ready === false)
            {
                console.log('interframe_unwrap: sodium not ready.');
                return false;
            }

            let outer = JSON.parse(s);
            if (!outer.hash || !outer.payload)
            {
                console.log('interframe_unwrap: message did not include hash or payload or both.');
                return false;
            }

            let calc_hash = sodium.crypto_generichash(16, sodium.from_string(outer.payload),
                                                       window.evernode_cookie, 'hex');

            if (calc_hash != outer.hash)
            {
                console.log('interframe_unwrap: message did not have the correct hash.');
                return false;
            }

            let inner = JSON.parse(outer.payload);
            if (!inner.nonce)
            {
                console.log('interframe_unwrap: message did not have a nonce.');
                return false;
            }


            if (inner.nonce <= window.other_nonce)
            {
                console.log('interframe_unwrap: message has an old or reused nonce (replay attack).');
                return false;
            }
        
            window.other_nonce = inner.nonce;            

            return inner.content;
        }

        function interframe_send(obj)
        {
            let m = window.interframe_wrap(obj);
            if (m === false)
                return;

            if (window.origin == 'null')
                return window.parent.postMessage(m, '*');

            return document.getElementById('sandbox').contentWindow.postMessage(m, '*');
        }

        window.addEventListener("message", (event) =>
        {
            if (event.origin == window.origin)
                return; // ignore self messages

            let j = interframe_unwrap(event.data);
            if (j === false)
                return; // invalid message

            if (j.type == 'resize')
            {
                document.getElementById('sandbox').style.height = j.data + 'px';
                return;
            }
        },false);

        function reset_sandbox(html)
        {

            window.evernode_cookie = new Uint8Array(64);
            window.evernode_cookie_current = "";
            crypto.getRandomValues(window.evernode_cookie);
            window.our_nonce = 0;
            window.their_nonce = 0;

            const inject1 = "<" + "script>\r\n" +
                            "window.evernode_cookie = new Uint8Array([" + window.evernode_cookie + "]);\r\n" + 
                            "window.our_nonce = 0;\r\n" + 
                            "window.their_nonce = 0;\r\n" + 
                            interframe_wrap.toString() + ";\r\n" + 
                            interframe_unwrap.toString() + ";\r\n" + 
                            interframe_send.toString() + ";\r\n" + 
                            "window.sodium = {\r\n" +
                            "ready: false,\r\n"+
                            "onload: \r\n" + 
                            "async function (sodium) {\r\n" +
                            "window.sodium = sodium; \r\n" +
                            "(new ResizeObserver(entries => {\r\n" + 
                            "console.log('resize observer fired');\r\n" +
                            "interframe_send(\r\n" + 
                            "{type: 'resize', data: \r\n" + 
                            "Math.max(document.body.scrollHeight, document.body.offsetHeight, " +
                            "document.documentElement.clientHeight, document.documentElement.scrollHeight, " + 
                            "document.documentElement.offsetHeight)\r\n" +
                            "});}\r\n"+
                            ")).observe(document.documentElement);\r\n" +
                            "}};<" + "/script>\r\n";

            const inject2 = '<'+'script src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/' + 
                            'sodium.min.js" integrity="sha512-oRfU7aik4u7f0dPAKgOyA4+bb/YRGfAaD5RA4Z3Mb2yc' +
                            'PcGDs+k8qAnDNd7ouruoqlIHSuGVaTTlEs91Gvd37A==" crossorigin="anonymous"><'+'/script>' + 
                            "\r\n";

            let sandbox_element = document.getElementById('sandbox');
            if (!sandbox_element)
                return console.log('sandbox element missing');

            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<!DOCTYPE[^>]+>/ig, '');
            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<html[^>]+>/ig, '');
            html = html.replaceAll(/^\s*/g, '');
            html = html.replaceAll(/^<head[^>]+>/ig, '');

            sandbox_element.srcdoc = "<!DOCTYPE HTML>\r\n<html>\r\n<head>\r\n" + inject1 + inject2 + html;
        }

        window.addEventListener("load", (event) =>
        {
            // open websocket connection/s
            // populate top bar
            // call info_main(cookie)
            // populate/create sandbox iframe

        }, false);

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/libsodium-wrappers/0.5.4/sodium.min.js"
        integrity="sha512-oRfU7aik4u7f0dPAKgOyA4+bb/YRGfAaD5RA4Z3Mb2ycPcGDs+k8qAnDNd7ouruoqlIHSuGVaTTlEs91Gvd37A=="
        crossorigin="anonymous"></script>
</head>
<body>
<div id="topbar">
    <div id="topbarflex">
        <div id="evernodeurl">
            evernode://98167360-e721-4165-bc30-7851804d734a [directory contract]
        </div>
        <div class="evernodepeer">
            wss://test.evernode.org
        </div>
    </div>
</div>


<iframe id="sandbox" src="#" seamless sandbox="allow-scripts" scrolling="no" srcdoc="Loading..."></iframe>

<script defer>
    reset_sandbox('test');
</script>
</body>
</html>
